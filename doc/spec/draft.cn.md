# Abstract Coded Designing Markup Language Alpha Edition Draft Specification

## Introduction

这是一份关于`ABCDML`(`Abstract Coded Designing Markup Language`，作为这项技术和生态的总称时亦可简写为`A4L`) Alpha的标准草案。ABCDML Alpha是一个完全处于全新设计中的版本，没有兼容性问题，这使得**本案所有内容都不具有稳定性**。

ABCDML（作为程序设计语言本身时不进一步简写为A4L）被设计为是一个主要面向非程序员的程序设计标记语言。它的侧重点在`UI（User interface）`布局，但允许使用者通过申明对辅助函数的调用来实现简单交互。

原则上，A4L不建议被用来开发功能复杂的、交互性极强的App，开发者应当把主要精力放在布局设计和基础交互设计上，而不要过多的考虑逻辑问题。标准库和官方框架以及社区会为开发者提供常用场景所需的交互逻辑组件和函数。考虑到极端情况，A4L保留了开发者使用自定义函数来强化应用功能的可行性，但这仍旧不是被建议的解决方案。本案的建议是，偏计算和偏业务逻辑的应用开发应当被合理评估并选择更适合它的开发语言。

在期望的实际开发中，`.abcdml`文档主要是充当隐式源文件的作用，文件中的ABCDML内容主要用作开发的中间数据和存储数据，开发者真正面对的是集成开发工具的可视化界面。这是出于对开发者的非程序员身份的考量。如非必要，开发者不需要真正的去编辑ABCDML。但一般而言，了解A4L的语法和思想，有助于开发、调试你的A4L应用程序。同时，完全用ABCDML编写A4L也是可行的，只是这需要强大的图形想象力。

## 1. Scoop

这份标准草案定义了A4L的词法、语法以及辅助函数和包的开发与使用，并描述了ABCDML抽象语法应当呈现出的布局与交互。

本标准草案不对目标语言及其下的A4L运行时框架进行定义和要求，只要它所实现的应用布局与交互体验能同A4L抽象语法树一一对应便可，本案不会关心和约束它的实现细节。

## 2. Overview

这一章主要介绍A4L应用程序的组成，开发与实现，整个标准草案其他章节的内容都不能与本章冲突。

### 2.1. Composition

A4L是一个面对组件的程序设计语言。A4L组件是A4L的基本单元（非最小单元），任何复杂的A4L应用程序都由一个或多个A4L组件组合而成，定义一个A4L组件我们需要定义他的各个属性。 毫无疑问，属性名都是字符串，属性的值则主要包括三类，标量、实体(组件的实例)和回调函数。

标量可细分为字符串、数值、布尔值和空值，其中字符串还可再次细分为多种子类型，我们将在字符串章节作详细说明。

广义上，组件可细分为纯组件、数据模型和数据可视化组件，对应的他们实体则被称为静态元素、状态集和动态元素；狭义上组件多指可视化组件，即纯组件和数据可视化组件，他们的实体则统称为元素（如无特别说明，后文中的元素皆指组件的可视化实体）。如何区分这些组件，将在组件章节详细说明。

申明回调函数是辅助函数的一种使用形式，了解回调函数之前我们需要先知道辅助。辅助函数主要用来帮助开发者处理一些数据和响应用户操作，使应用程序具备交互能力，其使用形式包括，申明回调函数作为事件监听属性的值用来响应事件，和直接调用辅助函数来返回计算后的标量和实体。本案类型章节将讲述如何申明回调函数和调用辅助函数计算。

辅助函数的定义和实现不属于ABCDML的描述范畴，但申明回调函数和调用辅助函数计算是ABCDML语法所支持的。我们希望辅助函数的定义方式一致，在不同的实现下表现出的效果一致，故定义AFD语法亦属于A4L标准的一部分，并将辅助函数的定义一同规范于在本案之后的辅助函数章节中。

### 2.2. Development

开发A4L主要就是合理的设计组件并将他们组织起来，而组织组件的形式其实是设计更高层的组件，归根结底设计A4L程序就是设计A4L的各层组件，也就是编写ABCDML文档。

一个A4L组件的定义实体就是一个书写了一个ABCDML组件定义表达式的`.abcdml`文件，任何人可以使用任何文字编辑软件来编辑这个文件。

由于A4L主要面向于非程序员，更准确的说是面向UI设计师，所以A4L在设计之初就将可视化集成开发工具考虑进来，从词法和语法设计上就为集成工具的实现作了准备。这些包括但不限于方便开发工具做检查的标量子类型系统和便于开发工具作调试功能的监控模块。这些特性是运行环境可以忽略的特性，完全是设计用来开发和调试的。本案相关章节中提及的调试方案皆是适用于生产环境的调试方案，关于使用监控模块进行调试的介绍将在附录中说明。

即便ABCDML本身包含了有利于开发工具提升效率的特性，开发工具自身并不是A4L的一部分，包括官方发布的集成工具也只是额外的辅助工具。本案将在附录中提出一些关于开发工具设计的建议，这些建议并非强制建议，但遵循它更有利于实现一个良好运作的A4L开发工具。

良好的开发习惯是使用开发工具（建议但不限制于官方集成开发工具）进行开发和调试，并使用优秀的应用框架进行构架，以UI布局为主线，搭配标准辅助函数或高评分的社区辅助函数来处理数据和交互。

### 2.3. Implementation

A4L是申明式的程序设计语言。语言本身不具备直接执行的能力，可编译到其他语言执行，也可由其他语言来解释执行。A4L的实现应遵守如下约定：

1. 编译或解释执行的起点是ABCDML抽象语法树（ABCDML AST），实现的第一步骤便是根据ABCDML和FND生成ABCDML抽象语法树。关于抽象语法树的定义，由本案进行统一规范，不得独自设计。但是解析方式仍是随意的。
2. 用于实现的语言及其下用于实现ABCDML的框架必须支持本案中所提到的所有A4L必要特性，如果目标框架（编译执行）或运行时环境（解释执行）不能达到此要求，则不能用来实现完整的标准A4L。
3. 编译执行或解释执行都需要先将ABCDML抽象语法树中的函数事先编译为一个或多个函数库, 保证输入输出一致。内置标准函数可以提前编译并集成到目标框架中。完整版本的A4L实现必须对辅助函数进行支持，且必须保证与本文档的描述的表现一致。
4. 编译执行需要将ABCDML抽象语法树中组件转译成目标框架中的等价组件（外观、交互等一致的组件和微件）。解释执行需要提供一个运行时环境，使其能根据ABCDML抽象语法树动态创建外观、交互等一致的组件。
5. 理论上，解释执行拥有更强的可调试性，编译执行则拥有更高的性能。不过，这取决于实现者自己的设计和拿捏，实现者亦可混合处理实现方式，或运用其他实现方式，但必须保证最终体验符合本案描述。本案只关注A4L的实现结果，不干涉A4L的实现细节。

## 3. Types
A4L有标量、实体和回调函数三种基本类型，这一章将对他们及他们的子类型进行定义。

### 3.1. 标量
标量都以字符串的形式存在，在编译或解释时才进行类型判定。

#### 3.1.1. 空值
空值

##### 3.1.1.1. 空项
空项表示一个对象存在，但不给他填充属性和元素，在代码中用来表示完全集成父组件或继承父组件的画板。

空项不是空值的一种，定义在此处正是为了强调它和空值进行区别。

空项在ABCDML文档使用符号连续双下划线`__`标记，这个符号也可称为`空项符`。下面的示例显示了一个组件完全继承另一个组件：

```abcdml
# SubComponent.abcdml

SubComponent<SuperComponent>: __
```

空项具有如下特征：
1. 空项是一种特殊的值，不是一种基本类型，被标为空项的对象可以是不同的类型。
2. 空项不单独使用，仅在语法层标识继承关系。
3. 空项在实例是包含属性或元素的，因为组件实例化时继承了父组件的构造。

#### 3.1.2. 数值

#### 3.1.3. 布尔值

#### 3.1.4. 文本

#### 3.1.5. 标量子类型

##### 3.1.5.1. 概率数

##### 3.1.5.2. 两位有效概率数

##### 3.1.5.3. 整数

##### 3.1.5.4. 正整数

##### 3.1.5.5. 序号/自然数

##### 3.1.5.6. 尺寸值

尺寸值由数字和单位构成，不同单位搭配的数字的精度也不相同，具体定义如下：

1.  `px`:  像素，0-+∞的整数
2.  `pt`:  点数，0-+∞的整数
3.  `tpw`: 1/12父级宽度倍数，0-12的整数
4.  `tph`: 1/12父级宽度倍数，0-12的整数
5.  `spw`: 1/63父级宽度倍数，0-63的整数
6.  `sph`: 1/63父级宽度倍数，0-63的整数
7.  `pw`:  1/100父级宽度倍数，0-+∞的两位小数
8.  `ph`:  1/100父级高度倍数，0-+∞的两位小数
9.  `vw`:  1/100视口宽度倍数，0-+∞的两位小数
10. `vh`:  1/100视口高度倍数，0-+∞的两位小数
11. `sfw`: 1/100安全区域宽度倍数，0-+∞的两位小数
12. `sfh`: 1/100安全区域高度倍数，0-+∞的两位小数
13. `scw`: 1/100屏幕宽度倍数，0-+∞的两位小数
14. `sch`: 1/100屏幕高度倍数，0-+∞的两位小数

##### 3.1.5.7. 纯字符

##### 3.1.5.8. 单词

##### 3.1.5.9. 标识

##### 3.1.5.10. 限制长度文本

### 3.2. 实体

#### 3.2.1. 状态集

#### 3.2.2. 元素

##### 3.2.2.1. 静态元素

### 3.3. 类型修饰符

### 3.4. 回调函数

## 4. Constants

## 5. ABCDML Syntax I - Component Declaration

这一章将定义ABCDML语法的主要构成，这些语法结构用于定义你的组件主体。
我们将从定义一个简单的组件开始，通过一点点增加其特征来穿插一个组件各部分细节的定义规则，最终得到一个较为完整的组件和一份完整的申明模板。

### 5.1. 命名规范

任何组件都必须有一个组件名，组件名在一个项目里面是唯一的。
组件名使用大坨峰命名风格，写在文档的开始（不包含注释和空白），并以冒号`:`结束。下面是一个名为HelloWorld的组件：

```abcdml
# src/HelloWorld.abcdml

HelloWorld:
  {}:
    width: 100pw
    height: 100ph
    bgColor: `#FFFFFF`
    color: <colors.black>
  []: 
    - Hello, this is my first A4L Component.
```

*这个组件是一个宽度为100%父级宽度，高度微100%父级高度的白色背景组件, 组件上有黑色`Hello, this is my first A4L App.`字样。这些细节将在接下来的章节进行定义。*

组件名前可以添加命名空间，这将使得复杂应用中可以出现同名组件，名空间直接放在组件名前面，并以斜杠`/`隔开，如下所示便是带有命名空间的组件：

```abcdml
# src/components/namespace_test/HelloWorld.abcdml

namespace_test/HelloWorld:
  {}:
    width: 100pw
    height: 100ph
    bgColor: <colors.gray>
  []: __
```
*此处`__`表示画板继承父组件画板*

A4L并未规定命名空间名称需与文件目录一致，但是实践中，我们建议将命名空间和文件目录按一定规则映射，这样有助于快速定位。
命名空间应当使用全小写英文字母，可使用下划线`_`分词，如需使用下标，建议使用罗马数字。
更好的实践是开发工具统一管理组件名、命名空间和文件。

### 5.2. 组件的静态属性

#### 5.2.1. 静态属性赋值

##### 5.2.1.1. 静态集合属性赋值

##### 5.2.1.2. 调用函数返回值进行赋值

### 5.3. 组件的动态属性

#### 5.3.1. 动态属性的定义

#### 5.3.2. 隐式属性

### 5.4. 组件的继承

#### 5.4.1. 终组件
终组件不可被继承，只能用于被实例化为元素。
终组件都是内建组件，用户组件都可被实例化和继承。

#### 5.4.2. 抽象组件
抽象组件不是真的组件，不可直接被实例化，但是可被继承。
抽象组件都是内建组件，用户组件都可被实例化和继承。

##### 5.4.2.1. 祖组件
*祖组件不是规范的必要部分，目标框架和运行时框架应视自身情况来选择是否实现它*

理论上，祖组件是所有组件的源头，实际上只要能保证各抽象组件的实现符合本案即可。

##### 5.4.2.2. 通用抽象组件
通用抽象组件是所有不指定父组件的用户组件的父组件。

##### 5.4.2.3. 私有抽象组件
私有抽象组件是内建组件的模板，既不可被实例化，也不可被继承。

## 6. Abstract Components List
本清单将定义所有抽象组件及其接口、属性和实现需求。
抽象组件不需要被实例化的特性使其完全是实现层的事情，故本章的定义语句都是伪代码。

## 7. ABCDML Syntax II - Component Instantiation

这一章将定义ABCDML语法中实例化组件的细节部分，这些语法结构用于组织你的所有组件。

### 7.1. 实例参数赋值

### 7.2. 读取状态

#### 7.2.1. 状态的作用域

### 7.3. 顶层组件实例化
每个A4L程序的顶层都只有两个组件，一个根元素组件，一个全局状态模型

#### 7.3.1. 根元素
应用组件

#### 7.3.2. 全局状态集
全局状态模型

### 7.4. 列表项元素实例化

## 8. Containers

这一章定义了所有的内建容器组件。

### 8.1. 图层组件

```abcdml
Layer:
  <<: 
    type: { Flow | Coords | Flex | Routes } = Flow
    direction: {} = horizontal
    base: { left-top | right-top | left-top | left-top} = left-top
    []: [ViewComponet]
  []: [Internal Implement]
```

### 8.2. 编组组件
编组组件是个伪组件

```abcdml
Group: 
  <<:
    name: id
    []: [ViewComponet]
  []: [Internal Implement]
```

### 8.3. 居中组件

```abcdml
# BuiltInComponent是私有
Center<BuiltInComponent>:
  <<:
    name: id
    child: ViewComponet
  {}: 
    classname: bic-container-center
  []: 
    - $child
```

## 9. Resource Components

这一章定义了所有的内建资源组件。

### 9.1. 媒体资源组件

#### 9.1.1. 图片资源组件

```abcdml
Image:
  <<:
    width: number
    height: number
    placeholder-file: text<types.FILENAME>
    src: text<types.URL>
    onload: callback = EMPTY
    onerror: callback = EMPTY
  >>:
    load: $onload
    error: $onerror
  []: [Internal Implement]
```

#### 9.1.2. 音频资源组件

#### 9.1.3. 视频资源组件

### 9.2. 网络资源组件

#### 9.2.1 XML资源解析组件

#### 9.2.2 JSON资源解析组件

#### 9.2.4 远程文件组件

### 9.3. 数据映射组件

#### 9.3.1. 数据表的定义

### 9.3. 数据映射组件

#### 9.3.1. 数据表的定义

#### 9.4. RESTful JSON资源映射组件

## 10. Branches And Loops

这一章定义了所有的内建逻辑组件。

### 10.1. 分支组件

#### 10.1.1. 按条件渲染组件

```abcdml
?:
  <<:
    if: [boolean]
    then: ViewComponet
    else:
```

#### 10.1.2. 按键名渲染组件

```abcdml
?:
  <<:
    # key 等价于 = { number | text }
    case: key
    # Cases 等价于 Map<key: ViewComponet>
    from: Cases
```

#### 10.1.3. 路由器组件

```abcdml
Router<RouterLike>:
  <<:
    []: [Route]
```

#### 10.1.3.1. 导航器组件
是页面级的路由器组件

```abcdml
Navigator<RouterLike>:
  <<:
    []: [Route]
```

### 10.2. 遍历与循环组件

```abcdml
List<ListLike>:
  <<:
    range: Range => RangeFromTo(0, 11)
    []
```

## 11. Form And Inputs

这一章定义了所有的内建表单组件。

## 12. Internationalization

这一章定义语言状态集模型、国际化组件，并规范他们的使用。

## 13. Events

这一章定义各种内建事件及其适用组件，并定义自定义事件。

## 14. Assistant Function Overview

这一章定义了辅助函数相关的规范。

### 14.1. 辅助函数定义

### 14.2. .fnd Document

### 14.3. 私有函数库

## 15. Built-in Standard Assistant Functions

这一章定义了所有内建辅助函数的输入和输出。

### 15.x. Range Generator

#### 生成一个基于左闭右闭原则的区间
Range Range.StartEnd(number start, number end, number  step = 1)

#### 生成一个基于左闭右开原则的区间
Range Range.StartTo(number start, number to, number  step = 1)

#### 生成一个基于左开右闭原则的区间
Range Range.FromEnd(number from, number end, number step = 1)

#### 生成一个基于左开右开原则的区间
Range Range.FromTo(number from, number to, number step = 1)

#### 以列表为原型生成一个区间
Range Range.Use(Map list)

#### 以状态为原型生成一个键区间
Range Range.KeysOf(Dict component)

#### 以状态集为原型生成一个值区间
Range Range.ValsOf(Dict component), 

### 15.x. 数据映射组件与RESTful远程JSON资源映射组件的操作

#### 增加记录

#### 删除记录

#### 修改记录

##### 修改部分字段

#### 查询记录

##### 按条件查询列表

## 16. Exception And Warning

这一章定义了异常和警告，并规范对他们的处理。

### 16.1. Exception

### 16.3. Warning

### 16.3. Monitoring Module
> 监控模块不是A4L必须实现的模块，它的生命周期可以和注释一样结束于ABCDML抽象语法树。而且即便要实现，只需要遵循的它输入输出接口协议来通讯即可，本案不定义它的视觉和交互体验。
> 此章可能会被删除

#### 16.3.1. 监控模块的应用
> 此章可能会被删除

## 17. Package Management

这一章定义包和包的管理

### 17.1. 使用社区Package

### 17.2. 使用私有Package

### 17.3. 发布Package

### 17.3.1. 发布纯函数库

## 18. ABCDML AST

这一章定义ABCDML语句应对应的抽象语法树结构

## A. 符号表

此附录提供所有符号语法的速查列表

## B. 开发工具设计建议

此附录是关于开发调试工具的相关问题的建议

### B.I. 官方集成开发工具特性清单

## C. 关于设计团队与设计初衷

此处附录一些关于我们的信息
